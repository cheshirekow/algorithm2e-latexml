#!/usr/bin/perl
# -*- CPERL -*-
# /=======================================================\ #
# |  algorithm2e.sty- implementation for LaTeXML          | #
# |                                                       | #
# |=======================================================| #
# | Copyright (c) 2011 Josh Bialkowski                    | #
# | Released under the GNU Public License v3              | #
# |=======================================================| #
# | Author: Josh Bialkowski                               | #
# | E-mail: jbialk@mit.edu                                | #
# \=======================================================/ #
# 
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
# 
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
# 
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 

package LaTeXML::Package;

use strict;
use LaTeXML::Package;


our $procString = "procedure";  
our $algoString = "algorithm";  # this is the string used to start/end our
                                # environment, it can be changed by the algo2e
                                # package option so that other algorithm 
                                # environments may coexist
    
# current defaults for all algorithms, is set with package options, and may
# be altered  by certain commands
our $globalSettings = 
{
    'lines-numbered'    => 1,           # increment line counter at each line
    'lines-labeled'     => 1,           # print a line label for each line
    'comments-numbered' => 0,           # includes comments in line numbering
    'inout-numbered'    => 0,           # makes data input/output be numbered
    'auto-reset-lines'  => 1,           # each algorithm resets the line counter
    'print-semicolon'   => 1,           # print the semicolon at line endings
    'caption-separator' => ':',         # string used between the word "algorithm"
                                        # and the title of the algorithm
    'print-caption'     => 1,           # whether or not to print "Algorithm # :"
                                        # in the title, only applies algo ruled
                                        # and ruled
    'lined-style'       => 'noline',    # lined, vlined, noline
    'boxed-style'       => 'plain',     # boxed, boxruled, ruled, algoruled, tworuled
    'end-style'         => 'shortend',  # longend, shortend, noend
};

our $algorithmSettings = $globalSettings;
our $lineSettings      = 
{
    'labels'                => [],  # list of any labels the user has given
                                    # this line
    'should-print-number'   => 1,   # true if we should print the line number
    'should-number'         => 1,   # true if we should generate a number for
                                    # this line
    'is-custom-text'        => 0,
    'number'                => 0,   # the line number for this line, is set to
                                    # refnum if should-number is true
    'reftext'               => '',  # this is the text that will be printed
                                    # whenever \ref{algo:some_label} is
                                    # used (is set to frefnum)
    'is-input'              => 0,   # set to true if it's an input line
    'is-comment'            => 0,   # set to true if it's a comment line
};

our $algoDepth = 1;             # the depth (in terms of pseudo code blocks)

our $globalNumbered = 1;        # all algos are numbered by default
our $globalLined    = 1;        # all algos are lined by default
our $globalVLined   = 1;        # all algos are vlined by default

our $localNumbered;             # this algo is auto-numbered
our $localLined;                # this algo is lined
our $localVLined;               # this algo is vlined

our $singleLineNumberOn;        # this line is numbered 
our $singleLineNumberOff;       # this line is not numbered

our $lineIsLabeled;             # the current line is labeled
our $lineIsNumbered;            # the current line is numbered

our $currentLineNumNode;        # pointer to the ltx:p element for the line 
                                # number of the current line
our $currentLineNode;           # pointer to the ltx:p element for the line we 
                                # are currently writing into
                                
our $currentAlgorithmNode;      # pointer to the ltx:float at the top level 
                                # of the current algorithm
our $currentCaptionNode;        # pointer to the ltx:caption element for the
                                # algorithm we are currently working on
our $restoreNode;               # swap space for whatever node is active when
                                # the caption node needs to be pulled into 
                                # active duty

# load the latxml scheme
# RelaxNGSchema('LaTeXML','ltx'=>'http://dlmf.nist.gov/LaTeXML');

# this is the algorithm counter
NewCounter('algoAlgo', 'document',  idprefix=>'A');

# this is the counter for blocks within an algorithm
NewCounter('algoBlock', 'algoAlgo', idprefix=>'B', idwithin=>'algoAlgo');

# this is the counter for lines within an algorithm
NewCounter('algoLine', 'algoAlgo',  idprefix=>'L', idwithin=>'algoAlgo');




#------------------------------------------------------------------------------
#                           Package Options
#------------------------------------------------------------------------------

# the algo2e option changes the string used to enter/exit the algorithm
# environment. It becomes "algorithm2e"
DeclareOption("algo2e",
sub
{
    $algoString = "algorithm2e";
});

# currently unsupported option
DeclareOption("slide",sub{});

# not applicable for latexml
DeclareOption("norelsize",sub{});

# currently unsupported, should make algorithms put in classical figure 
# environment, and therefore added to \listoffigures
DeclareOption("figure",sub{});


# Declare package options which merely set values of the globalSettings
# structure

# I can't believe this actually works... perl is amazing
for my $boxstyle( qw(boxed boxruled ruled algoruled tworuled plain) )
{
    DeclareOption($boxstyle,
        sub{$globalSettings->{'boxed-style'} = $boxstyle;}
    );    
}

for my $linedstyle( qw(lined vlined noline) )
{
    DeclareOption($linedstyle,
        sub{$globalSettings->{'lined-style'} = $linedstyle;}
    );    
}

for my $endstyle( qw(longend shortend noend) )
{
    DeclareOption($endstyle,
        sub{$globalSettings->{'end-style'} = $endstyle;}
    );
}

DeclareOption('linesnumbered',
                            sub{$globalSettings->{'lines-numbered'}     = 1;});

DeclareOption('linesnumberedhidden',
                            sub{$globalSettings->{'lines-labeled'}   = 0;});

DeclareOption('commentsnumbered',
                            sub{$globalSettings->{'comments-numbered'} = 1;});    

DeclareOption('inoutnumbered',
                            sub{$globalSettings->{'inout-numbered'}    = 1;});

DeclareOption('resetcount', 
                            sub{$globalSettings->{'auto-reset-lines'}  = 1;});

DeclareOption('noresetcount',
                            sub{$globalSettings->{'auto-reset-lines'}  = 0;});
                            
                            
#------------------------------------------------------------------------------
#                           Basic Typesetting Commands
#------------------------------------------------------------------------------

DefConstructor('\DontPrintSemicolon', 
                            sub{$algorithmSettings->{'print-semicolon'} = 0;});
DefConstructor('\DontPrintSemicolon', 
                            sub{$algorithmSettings->{'print-semicolon'} = 1;});

DefConstructor('\BlankLine',  '\algoEndLine');


#------------------------------------------------------------------------------
#                           Setting Global Styles
#------------------------------------------------------------------------------

DefConstructor('\SetAlgoCaptionSeparator',
sub
{
    my ($gullet,$arg)= @_;
    $globalSettings->{'caption-separator'} = $arg;    
});

DefConstructor('\NoCaptionOfAlgo',      sub{$globalSettings->{'print-caption'} = 0;});
DefConstructor('\RestoreCaptionOfAlgo', sub{$globalSettings->{'print-caption'} = 1;});





#------------------------------------------------------------------------------
#                           Labeling and Numbering
#------------------------------------------------------------------------------

DefConstructor('\LinesNumbered',        sub{$globalSettings->{'lines-numbered'} = 1;});
DefConstructor('\LinesNumberedHidden',  sub{$globalSettings->{'lines-labeled'}  = 0;});

# macros for labeling lines 
# in the latex version \nllabel, \lnl, and \label all kind of do different
# things, however, since we postpone generating a line number until the
# line is digested, and each of these macros only makes sense if the line
# is numbered, we can make them all do the same things
for my $macroName (qw(\nllabel{} \lnl{} \algoLabel{}))
{
    DefMacro($macroName, 
    sub
    {
        # add the new label to the list of labels for this line
        my ($gullet, $arg) = @_;
        my $labelArray     = $lineSettings->{'labels'};
        push( @$labelArray, $arg );
        
        # ensure that this line will get a number
        $lineSettings->{'should-number'} = 1;
        
        #return empty list of tokens
        ()
    });
}


# indicates that the current line should be numbered. In LaTeX, this must come
# first in the line, but we don't actually care for latexml
DefMacro('\nl', 
sub
{
    $lineSettings->{'should-number'} = 1;
    
    #return empty list of tokens
    ()
});

# set the text for the line "number" output, instead of outputting the actual
# line number, will also be the text output when we use \ref{} if the 
# line is labeled
DefMacro('\nlset{}',
sub
{
    # set the custom text
    my ($gullet, $arg) = @_;
    $lineSettings->{'reftext'} = $arg;
    
    # set the flag indicating that it is custom text
    $lineSettings->{'is-custom-text'}=1;
    
    #return empty list of tokens
    ()
});

# set the text for the line "number" output and a label for the line at the
# same time
DefMacro('\nlset{}{}',
sub
{
    # set the custom text
    my ($gullet, $text, $label) = @_;
    my $labelArray     = $lineSettings->{'labels'};
    $lineSettings->{'reftext'} = $text;
    push( @$labelArray, $label );
    
    # set the flag indicating that it is custom text
    $lineSettings->{'is-custom-text'}=1;
    
    #return empty list of tokens
    ()
});

# indicates that theline number (or text) should be displayed, even if 
# the linesnumbered hidden is activated
DefMacro('\ShowLn',
sub
{
    $lineSettings->{'should-print-number'}=1;
    
    #return empty list of tokens
    ()
});

# indicates that theline number (or text) should be displayed, and adds a label
# at the same time
DefMacro('\ShowLn{}',
sub
{
    # set the custom text
    my ($gullet, $label) = @_;
    my $labelArray = $lineSettings->{'labels'};
    push( @$labelArray, $label );
    
    $lineSettings->{'should-print-number'}=1;
    
    #return empty list of tokens
    ()
});




                            
# ------------------------------------------------------------------------------
#                            default style macros
# ------------------------------------------------------------------------------

# -------------------------------------------------
#                  Standard Styles
# -------------------------------------------------
DefMacro('\KwSty{}'      , '\textbf{#1}'      );
DefMacro('\FuncSty{}'    , '\texttt{#1}'      );
DefMacro('\ArgSty{}'     , '\emph{#1}'        );
DefMacro('\DataSty{}'    , '\textsf{#1}'      );
DefMacro('\CommentSty{}' , '\texttt{#1}'      );
DefMacro('\NlSty{}'      , '\relsize{-2}{#1}' );
DefMacro('\ProcNameSty{}', '\relsize{-2}{#1}' );
DefMacro('\ProcArgSty{}' , '\relsize{-2}{#1}' );

# -------------------------------------------------
#              Caption and Title Style
# -------------------------------------------------
DefMacro('\AlCapSty{}'      , '\textbf{#1}'     );
DefMacro('\AlCapNameSty{}'  , '\textnormal{#1}' );
DefMacro('\AlCapFnt{}'      , '\relax{#1}'      );
DefMacro('\AlCapNameFnt{}'  , '\relax{#1}'      );
DefMacro('\AlTitleSty{}'    , '\textbf{#1}'     );
DefMacro('\AlTitleFnt{}'    , '\relax{#1}'      );



# macros to redefine styles, each of these macros takes a single argument which
# is the textual name of a macro which takes a single argument
for my $styleKey(qw(
        Kw Func Arg Data Comment ProcName ProcArg 
        AlCapSty AlCapNameSty AlCapFnt AlCapNameFnt 
        AlTitleSty AlTitleFnt
))
{
    my $setterMacro = sprintf('\Set%sSty{}', $styleKey);
    my $styleMacro  = sprintf('\%sSty{}',    $styleKey);
    
    DefMacro($setterMacro,
    sub
    {
        my ($gullet, $arg) = @_;
        DefMacro($styleMacro, sprintf('\%s{#1}', $arg));
        
        # return empty token list
        ();
    });    
}

# the NlStyle macro (number line style) takes three arguments. First is the
# Style macro, then a prefix, then a suffix so that the line printed is like
# \textbf{ prefix #1 suffix }
DefMacro('\SetNlSty{}{}{}',
sub
{
    my ($gullet, $font,$pre,$post) = @_;
    DefMacro('\NlSty{}', sprintf('\%s{ %s #1 %s}', $font,$pre,$post));
    
    # return empty token list
    ();
});




# ------------------------------------------------------------------------------
#                            Controlloing Layout
# ------------------------------------------------------------------------------

# sets the boxed style of all following algorithms
DefMacro('\RestyleAlgo{}',
sub{
    
    my ($gullet, $arg) = @_;
    $globalSettings->{'boxed-style'} = $arg;
    
    # return empty token list
    ();
});

# sets the lined style 
for my $style( qw( Vlined Noline Lined ) )
{
    my $setterMacro = sprintf('\SetAlgo%s', $style);
    my $value       = lc($style);
    DefMacro($setterMacro,
    sub
    {
        $globalSettings->{'lined-style'} = $value;    
        
        # return empty token list
        return ();
    });
}

# sets the end style
for my $style( qw(LongEnd ShortEnd NoEnd) )
{
    my $setterMacro = sprintf('\SetAlgo%s', $style);
    my $value       = lc($style);
    DefMacro($setterMacro,
    sub
    {
        $globalSettings->{'end-style'} = $value;    
        
        # return empty token list
        return ();
    });
}


# ------------------------------------------------------------------------------
#                       Utility macros
# ------------------------------------------------------------------------------
DefMacro('\algoSetInputLine',
sub
{
    $lineSettings->{'is-input'} = 1;
});

DefMacro('\algoSetCommentLine',
sub
{
    $lineSettings->{'is-comment'} = 1;
});

# ------------------------------------------------------------------------------
#                       Setting new Keywords
# ------------------------------------------------------------------------------
our $CreateKwInputMacro = 
sub
{
    my ($gullet,$macro,$text) = @_;    
    my $command     = sprintf('\%s',$macro);
    my $expansion   = sprintf('\algoSetInputLine \KwSty{%s}', $text);
    
    DefMacro($command,$expansion);
    
    # return empty token list
    ();
};


DefMacro('\SetKwInput{}{}',$CreateKwInputMacro);

our $CreateKwMacro =
sub
{
    my ($gullet, $macro,$text) = @_;    
    
    my $command     = sprintf('\%s',$macro);
    my $expansion   = sprintf('\KwSty{%s}', $text);
    
    DefMacro($command,$expansion);
    
    # return empty token list
    ();
};

DefMacro('\SetKw{}{}',$CreateKwMacro);


our $CreateCommentMacro =
sub
{
    my ($gullet, $macro,$open,$close) = @_;    
    
    my $command     = sprintf('\%s',$macro);
    my $expansion   = sprintf('\algoSetCommentLine \CommentSty{ %s #1 %s }', 
                                $open, $close);
    
    DefMacro($command,$expansion);
    
    # return empty token list
    ();
};


DefMacro('\SetKwComment{}{}{}',$CreateCommentMacro);


our $CreateIfMacros =
sub
{
    my($gullet,
        $ifMacro,$elseIfMacro,$elseMacro,
        $ifString,$thenString,$elseifString,
        $elseString,$endString) = @_; 
        
    # normal if statement with end statement and contents are a block
    DefMacro(
        sprintf('\%s{}{}', $ifMacro),
        sprintf('\KwSty{%s} #1 \KwSty{%s} '
                .'\algoBeginBlock #2 \algoEndBlock '
                .'\KwSty{%s} \algoEndLine', 
                $ifString,
                $thenString,
                $endString
                )
            );
    
    # unfinished if statement, does not print an end so that an else can be
    # appended
    DefMacro(
        sprintf('\u%s{}{}', $ifMacro),
        sprintf('\KwSty{%s} #1 \KwSty{%s} '
                .'\algoBeginBlock #2 \algoEndBlock ',
                $ifString,
                $thenString
                )
            );
    
    # single line if statment, then block is on the same line
    DefMacro(
        sprintf('\l%s{}{}', $ifMacro),
        sprintf('\KwSty{%s} #1 \KwSty{%s} #2',
                $ifString,
                $thenString
                )
            );
    
    # same as if except uses 'elseif', used for continuation of uIf or lIf
    DefMacro(
        sprintf('\%s{}{}', $elseIfMacro),
        sprintf('\KwSty{%s} #1 \KwSty{%s} '
                .'\algoBeginBlock #2 \algoEndBlock '
                .'\KwSty{%s} \algoEndLine', 
                $elseifString,
                $thenString,
                $endString
                )
            );
    
    # unfinished elseif
    DefMacro(
        sprintf('\u%s{}{}', $elseIfMacro),
        sprintf('\KwSty{%s} #1 \KwSty{%s} '
                .'\algoBeginBlock #2 \algoEndBlock ',
                $elseifString,
                $thenString
                )
            );
    
    # single line elseif
    DefMacro(
        sprintf('\l%s{}{}', $elseIfMacro),
        sprintf('\KwSty{%s} #1 \KwSty{%s} #2',
                $elseifString,
                $thenString
                )
            );
            
            
    # normal else statement with end statement and contents are a block
    DefMacro(
        sprintf('\%s{}', $elseMacro),
        sprintf('\KwSty{%s}  '
                .'\algoBeginBlock #1 \algoEndBlock '
                .'\KwSty{%s} \algoEndLine', 
                $elseString,
                $endString
                )
            );
    
    # unfinished else statement, does not print an end so that an else can be
    # appended
    DefMacro(
        sprintf('\u%s{}', $elseMacro),
        sprintf('\KwSty{%s} '
                .'\algoBeginBlock #1 \algoEndBlock ',
                $elseString
                )
            );
    
    # single line else statment, then block is on the same line
    DefMacro(
        sprintf('\l%s{}', $elseMacro),
        sprintf('\KwSty{%s} #2',
                $elseString
                )
            );

    # combined if-else statement
    DefMacro('\eIf{}{}{}',  '\uIf{1}{2} \Else{3}');
   
   #return empty token list     
   ();
};

DefMacro('\SetKwIF{}{}{}{}{}{}{}{}',$CreateIfMacros);




# ------------------------------------------------------------------------------
#                       Predefined Language Keywords
# ------------------------------------------------------------------------------
for my $pairs(  [qw(KwIn     Input)],
                [qw(KwData   Data)],
                [qw(KwOut    Output)],
                [qw(KwResult Result)]  )
{
    $CreateKwInputMacro->( 'gullet', $pairs->[0], $pairs->[1] );
}

for my $pairs(  [qw(KwTo    to)],
                [qw(KwRet   Return)],
                [qw(Return  Return)] )
{
    $CreateKwMacro->( 'gullet', $pairs->[0], $pairs->[1] );
}

DefMacro('\tcc{}',      '\CommentSty{ /* #1 */ }'  );
DefMacro('\tcc*{}',     '\CommentSty{ /* #1 */ }'  );
DefMacro('\tcp{}',      '\CommentSty{ // #1    }'  );
DefMacro('\tcp*{}',     '\CommentSty{ // #1    }'  );

DefMacro('\KwEnd',      '\KwSty{end}'       );

# if macros
CreateIfMacros( qw(gullet If ElseIf Else if then elseif else endif) );


# switch statement
DefMacro('\Switch{}{}',  '\KwSty{switch} #1 '
                        .'\algoBeginBlock #2 \algoEndBlock '
                        .'\KwSty{end}');

# case statement
DefMacro('\Case{}{}',  '\KwSty{case} #1 :'
                       .'\algoBeginBlock #2 \algoEndBlock '
                       .'\KwSty{end}');

# unfinished case statement
DefMacro('\uCase{}{}',  '\KwSty{case} #1 :'
                       .'\algoBeginBlock #2 \algoEndBlock ');
                       
# singe line case statement
DefMacro('\lCase{}{}',  '\KwSty{case} #1 : #2 ');

# otherwise
DefMacro('\Other{}',  '\KwSty{otherwise} :'
                       .'\algoBeginBlock #1 \algoEndBlock '
                       .'\KwSty{end}');

# singe line otherwise
DefMacro('\lOther{}',  '\KwSty{otherwise} : #1 ');






DefMacro('\While{}{}',  '\KwSty{while} #1 \KwSty{do}   \algoBeginBlock #2 \algoEndBlock \KwSty{end} \algoEndLine');
DefMacro('\For{}{}',    '\KwSty{for  } #1 \KwSty{do}   \algoBeginBlock #2 \algoEndBlock \KwSty{end} \algoEndLine');

DefMacro('\algoCaption{}',  '\beginAlgoCaption {#1} \endAlgoCaption');
    



# In user code (i.e a latex document) the user only ever gives us an indication
# of ending a line (\;). We will do layout at the line level so what we'll do
# is any time we come across one of these line endings we'll put a "line split"
# in other words we always assume that there is an open "line" xml block. Then,
# when we hit one of thise (\;) control codes, what we'll do is split that 
# currently open line, so that everything currently digested goes before the
# split, and there now "current" line is empty
#
# An alternate explanation. There is always a current "line". As we digest code
# we put it into that line. Then when we hit a (\;) control code, we split that
# current line after whatever has been digested so far. The left half of that 
# split is considered done, and the right half is where future digestion
# gets output.
DefConstructor('\algoEndLine',sub{
    my $document = shift;
    algoEndLine($document);
    algoBeginLine($document);
}); 

# When we start a new block we need to close the currenly opened line, then
# start a new block, and then start a new line within that block
DefConstructor('\algoBeginBlock',sub{
    my $document = shift;
    algoEndLine($document);
    algoBeginBlock($document);
    algoBeginLine($document);
});

# when we end a block, we need to close the active line, then close the active
# block, and then open a new line so that more stuff can be put into it
DefConstructor('\algoEndBlock',sub{
	my $document = shift;
	algoCancelLine($document);
	algoEndBlock($document);
	algoBeginLine($document);
});


# when the algorithm environment is started we need to insert some custom 
# code handlers before digestion proceeds
DefConstructor('\algorithm[]',
    sub 
    {
        # to start the algorithm block, we open the environment,
        # then the first block in that environment, then the first line in
        # that block
    	my $document = shift;
    	algoBeginEnv($document);
    	algoBeginBlock($document);
    	algoBeginLine($document);
    },
    # before digestion, we need to redefine some commands so that 
    beforeDigest=>
    sub{
    	my $stomach = shift;
    	
    	# store the current meaning of '\;' and '\caption' so that we can 
    	# restore them later
    	Let('\algoOldSemicolon',   '\;');
    	Let('\algoOldCaption',     '\caption');
    	Let('\algoOldLabel',       '\label');
    	
    	# now redefine them to our binding hooks so that we are notified when
    	# these controls are encountered
    	Let('\;'      ,   '\algoEndLine');
    	Let('\caption',   '\algoCaption');
    	Let('\label',     '\algoLabel');
    }    
);

# when the algorithm environment is ended we need to restore the old definitions
# for the \; and \caption controls
DefConstructor('\endalgorithm',
    sub
    {
        # since the algorithm is ended we close the current line and delete it
        # (because it should be empty) then close the open block and the open
        # environment
    	my $document = shift;
    	algoCancelLine($document);
    	algoEndBlock($document);
    	algoEndEnv($document);
    },
    beforeDigest=>
    sub
    {
        my $stomach = shift;
        Let('\;',       '\algoOldsemicolon');
        Let('\caption', '\algoOldCaption');
        Let('\label',   '\algoOldLabel');
    }
);

# if we encounter a caption for the algorithm, we make the caption element
# the active element of the document, so that the caption code gets digested
# into the correct part of the document tree
DefConstructor('\beginAlgoCaption',sub{
	my $document = shift;
	
	# we cache the current node (whatever it is) so that when the caption is
	# complete we can make it current again
	$restoreNode = $document->getNode;
	
	# now set the "current" or active node to be the caption element
	$document->setNode($currentCaptionNode);
});

# when the caption is digested, we restore whatever active node was set prior
# to the caption being started
DefConstructor('\endAlgoCaption',sub{
	my $document = shift;
	$document->setNode($restoreNode);
});

# the \algoSingleLineNumberOff control indicates that this line should not
# be numbered, so we simply set the flag
DefConstructor('\algoSingleLineNumberOff',sub{$singleLineNumberOff=1;});

# the \algoSingleLineNumberOn control indicates that this line should be
# numbered, so we simply set the flag
DefConstructor('\algoSingleLineNumberOn', sub{$singleLineNumberOn =1;});



# Begins outputting an algorithm to the xml document
# 
# an algorithm environment maps to a <ltx:float> in latxml schema 
# this in turn maps to an html <div>.
# signature: algoBeginEnv( $document ) 
sub algoBeginEnv
{
    # parameter is the xml document
    my $document = shift;
    
    # create a reference uid by incrementing the 'algorithm'
    # counter. This counter prefixes the counter number with 'A' so
    # algorithm 4 would have a ref name of "A4"
    my %ref      = RefStepCounter('algoAlgo');
    
    # open the ltx:float element
    $document->openElement("ltx:float");
    
    # add the attributes needed for cross referencing
    $document->addAttribute("refnum"=>$ref{'refnum'});
    $document->addAttribute("xml:id"=>$ref{'id'});
    
    # add the algorithm2e class name (this will become a css class name in the
    # class attribute of the html div element)
    $document->addAttribute("class"=>"algorithm2e");
    
    # now open a caption child element to the algorithm give it a 
    # class name of algorithm2e-caption so we can style it, and then
    # immediately close it. We grab a pointer to this node before we
    # close it
    #
    # The reason we do it this way is that the user may or may not 
    # include a caption. But if they do it will likely be at the end
    # of the environment. We need to be able to insert the caption
    # text wherever we find the caption. 
    $document->openElement("ltx:caption");
    $document->addAttribute("class"=>"algorithm2e-caption");
    $currentCaptionNode = $document->getNode;
    $document->closeElement("ltx:caption");
    
    # initialize the depth to 0. This is the depth in terms of code
    # blocks (loops, conditionals) and dictates how far to increment
    # the code block
    $algoDepth   = 0;

    # set the settings of this algorithm to be those of the document defaults,
    # note that they may be changed when certain macros within the environment
    # are encountered
    $localNumbered = $globalNumbered;
    $localLined    = $globalLined;
    $localVLined   = $globalVLined;
    
    # these variables indicate that the user has specifically stated
    # that a particular line is numbered or not, it can be used to
    # override the line numbering setting for the whole algorithm
    $singleLineNumberOff = 0;
    $singleLineNumberOn  = 0;
}

# End outputting an algorithm to the xml document
#
# At the close of the algorithm environment we simply close the 
# opened ltx:float element
sub algoEndEnv
{
	my $document = shift;
    $document->closeElement("ltx:float");
}

# Begin outputting a block of algorithm code
#
# A block of algorithm code is reprsented in the xml schema by an
# ltx:inline-block element. 
sub algoBeginBlock
{
	my $document = shift;
	
	# increment the block counter so that we can get unique 
	# reference entry for this block
	my %ref      = RefStepCounter('algoBlock');
	
	# increment the algorithm depth (i.e. how deep in the nested
	# block structure of the algorithm we are)
    $algoDepth = $algoDepth + 1;
    
    # now open the actual element
    $document->openElement("ltx:inline-block");
    
    # set the depth attribute of the inline-block element to be the
    # depth of the block (this is an abuse and should be changed, 
    # perhaps we can use a fixed number of block classes instead)
    if( $algoDepth > 1 )
    {
        $document->addAttribute(
            "class"=>sprintf("algorithm2e-block-x",$algoDepth) );
    }
    else
    {
        $document->addAttribute(
            "class"=>sprintf("algorithm2e-block-0",$algoDepth) );
    }
    
    # set the cross reference information based on the counter for
    # algorithm blocks
    $document->addAttribute("refnum"=>$ref{'refnum'});
    $document->addAttribute("xml:id"=>$ref{'id'});
}

# End output of a block of algorithm cocde
sub algoEndBlock
{
	my $document = shift;
	
	# first close the ltx:inline-block element
	$document->closeElement("ltx:inline-block");
	
	# then we decrement the depth
	$algoDepth = $algoDepth - 1;
}

# Starts a new algorithm line
#
# A line of pseudo code maps to a ltx:p element
sub algoBeginLine
{
    my $document = shift;
    
    # we open a ltx:p element, and cache a reference to it. 
    $currentLineNode = $document->openElement("ltx:p");
    
    # assign a class name of algoirthm2e-line so that we can style it with
    # css
    $document->addAttribute("class"=>"algorithm2e-line");
}

# End output of an algorithm line
sub algoEndLine
{
	my $document = shift;
	
	# we may have to do line numbering on this line if
	#     1. the latex code explicitly sets this line to use numbering
	#     2. the policy for this algorithm is to do line numbering and the
	#        latex code has not explicitly turned of line numbering for this
	#        line
    if($singleLineNumberOn || ($localNumbered && !$singleLineNumberOff) )
    {
        # if we do need to do line numbering, then we step the counter
    	my %ref = RefStepCounter('algoLine');
    	
    	# and add attributes so that the line can be cross referenced
	    $currentLineNode->setAttribute("refnum",ToString($ref{'refnum'}));
	    $currentLineNode->setAttribute("xml:id",ToString($ref{'id'}));
	    $currentLineNode->setAttribute("label",
                               sprintf("LABEL:%s user_label_%s",
                                        ToString($ref{'id'}),
                                        ToString($ref{'id'})   ) );
    }
    else
    {
    	# otherwise, we just do nothing
    }
    
    # then we close the opened ltx:p element
    $document->closeElement("ltx:p");
    
    # and we reset any explicit settings for "the current line"
    $singleLineNumberOff = 0;
    $singleLineNumberOn  = 0;
}

# Since we always have one line open, we may need to remove the last line
# from the document after the algorithm is complete
sub algoCancelLine
{
    my $document = shift;
    my $node = $document->getElement("ltx:p");
    #$document->closeElement("ltx:p");
    #$node->parentNode->removeChild($node);
}




1;
