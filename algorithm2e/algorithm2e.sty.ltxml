#!/usr/bin/perl
# -*- CPERL -*-
# /=======================================================\ #
# |  algorithm2e.sty- implementation for LaTeXML          | #
# |                                                       | #
# |=======================================================| #
# | Copyright (c) 2011 Josh Bialkowski                    | #
# | Released under the GNU Public License v3              | #
# |=======================================================| #
# | Author: Josh Bialkowski                               | #
# | E-mail: jbialk@mit.edu                                | #
# \=======================================================/ #
# 
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
# 
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
# 
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 

package LaTeXML::Package;

use strict;
use LaTeXML::Package;
use Storable qw(dclone);

our $procString = "procedure";  
our $algoString = "algorithm";  # this is the string used to start/end our
                                # environment, it can be changed by the algo2e
                                # package option so that other algorithm 
                                # environments may coexist
    
# current defaults for all algorithms, is set with package options, and may
# be altered  by certain commands
our $globalSettings = 
{
    'lines-numbered'    => 1,           # increment line counter at each line
    'lines-labeled'     => 1,           # print a line label for each line
    'comments-numbered' => 0,           # includes comments in line numbering
    'input-numbered'    => 0,           # makes data input/output be numbered
    'auto-reset-lines'  => 1,           # each algorithm resets the line counter
    'print-semicolon'   => 1,           # print the semicolon at line endings
    'caption-separator' => ':',         # string used between the word "algorithm"
                                        # and the title of the algorithm
    'print-caption'     => 1,           # whether or not to print "Algorithm # :"
                                        # in the title, only applies algo ruled
                                        # and ruled
    'lined-style'       => 'noline',    # lined, vlined, noline
    'boxed-style'       => 'plain',     # boxed, boxruled, ruled, algoruled, tworuled
    'end-style'         => 'shortend',  # longend, shortend, noend
    'is-captioned'      => 0,           # set to true when the caption
                                        # constructor is called, this enables
                                        # the label constructor to deal with
                                        # line labels and algorithm labels 
                                        # separately
    'algo-number'       => 0,           # set by the counter in BeginEnv
};

our $algorithmSettings = $globalSettings;
our $defaultLineSettings      = 
{
    'labels'                => [],  # list of any labels the user has given
                                    # this line
    'should-print-number'   => 0,   # true if we should print the line number
    'should-number'         => 0,   # true if we should generate a number for
                                    # this line
    'is-custom-text'        => 0,
    'number'                => 0,   # the line number for this line, is set to
                                    # refnum if should-number is true
    'reftext'               => '',  # this is the text that will be printed
                                    # whenever \ref{algo:some_label} is
                                    # used (is set to frefnum)
    'is-input'              => 0,   # set to true if it's an input line
                                    # construction flag
    'is-comment'            => 0,   # set to true if it's a comment line
                                    # construction flag
    'is-hidden'             => 0,   # set to true if this is an end[x] line
                                    # construction flag
};

our $lineSettings     = {};
$lineSettings         = dclone($defaultLineSettings);

our $algoDepth = 1;             # the depth (in terms of pseudo code blocks)

our $globalNumbered = 1;        # all algos are numbered by default
our $globalLined    = 1;        # all algos are lined by default
our $globalVLined   = 1;        # all algos are vlined by default

our $localNumbered;             # this algo is auto-numbered
our $localLined;                # this algo is lined
our $localVLined;               # this algo is vlined

our $singleLineNumberOn;        # this line is numbered 
our $singleLineNumberOff;       # this line is not numbered

our $lineIsLabeled;             # the current line is labeled
our $lineIsNumbered;            # the current line is numbered

our $currentLineLabelNode;      # pointer to the ltx:p element for the line 
                                # number of the current line
our $currentLineNode;           # pointer to the ltx:p element for the line we 
                                # are currently writing into
                                
our $currentAlgorithmNode;      # pointer to the ltx:float at the top level 
                                # of the current algorithm
our $currentCaptionNode;        # pointer to the ltx:caption element for the
                                # algorithm we are currently working on
our $restoreNode;               # swap space for whatever node is active when
                                # the caption node needs to be pulled into 
                                # active duty

# load the latxml scheme
# RelaxNGSchema('LaTeXML','ltx'=>'http://dlmf.nist.gov/LaTeXML');

# this is the algorithm counter
NewCounter('algoAlgo', 'document',  idprefix=>'A');

# this is the counter for blocks within an algorithm
NewCounter('algoBlock', 'algoAlgo', idprefix=>'B', idwithin=>'algoAlgo');

# this is the counter for lines within an algorithm
NewCounter('algoLine', 'algoAlgo',  idprefix=>'L', idwithin=>'algoAlgo');




#------------------------------------------------------------------------------
#                           Package Options
#------------------------------------------------------------------------------

# the algo2e option changes the string used to enter/exit the algorithm
# environment. It becomes "algorithm2e"
DeclareOption("algo2e",
sub
{
    $algoString = "algorithm2e";
});

# currently unsupported option
DeclareOption("slide",sub{});

# not applicable for latexml
DeclareOption("norelsize",sub{});

# currently unsupported, should make algorithms put in classical figure 
# environment, and therefore added to \listoffigures
DeclareOption("figure",sub{});


# Declare package options which merely set values of the globalSettings
# structure

# I can't believe this actually works... perl is amazing
for my $boxstyle( qw(boxed boxruled ruled algoruled tworuled plain) )
{
    DeclareOption($boxstyle,
        sub{$globalSettings->{'boxed-style'} = $boxstyle; return;}
    );    
}

for my $linedstyle( qw(lined vlined noline) )
{
    DeclareOption($linedstyle,
        sub{$globalSettings->{'lined-style'} = $linedstyle; return;}
    );    
}

for my $endstyle( qw(longend shortend noend) )
{
    DeclareOption($endstyle,
        sub{$globalSettings->{'end-style'} = $endstyle; return;}
    );
}

DeclareOption('linesnumbered',
                            sub{printf("\n\nSetting Lines numbered\n");$globalSettings->{'lines-numbered'}  = 1; return;});

DeclareOption('linesnumberedhidden',
                            sub{$globalSettings->{'lines-labeled'}   = 0; return;});

DeclareOption('commentsnumbered',
                            sub{$globalSettings->{'comments-numbered'} = 1; return;});    

DeclareOption('inoutnumbered',
                            sub{$globalSettings->{'input-numbered'}    = 1; return;});

DeclareOption('resetcount', 
                            sub{$globalSettings->{'auto-reset-lines'}  = 1; return;});

DeclareOption('noresetcount',
                            sub{$globalSettings->{'auto-reset-lines'}  = 0; return;});
                            
ProcessOptions();
                            
                            
#------------------------------------------------------------------------------
#                           Basic Typesetting Commands
#------------------------------------------------------------------------------

DefConstructor('\DontPrintSemicolon', 
                            sub{$algorithmSettings->{'print-semicolon'} = 0;});
DefConstructor('\DontPrintSemicolon', 
                            sub{$algorithmSettings->{'print-semicolon'} = 1;});

DefConstructor('\BlankLine',  '\algoEndLine');


#------------------------------------------------------------------------------
#                           Setting Global Styles
#------------------------------------------------------------------------------

DefMacro('\SetAlgoCaptionSeparator',
sub
{
    my ($gullet,$arg)= @_;
    $globalSettings->{'caption-separator'} = $arg;    
});

DefMacro('\NoCaptionOfAlgo',      sub{$globalSettings->{'print-caption'} = 0; return ();});
DefMacro('\RestoreCaptionOfAlgo', sub{$globalSettings->{'print-caption'} = 1; return ();});





#------------------------------------------------------------------------------
#                           Labeling and Numbering
#------------------------------------------------------------------------------

DefMacro('\LinesNumbered',        sub{$globalSettings->{'lines-numbered'} = 1; return ();});
DefMacro('\LinesNumberedHidden',  sub{$globalSettings->{'lines-labeled'}  = 0; return ();});

# macros for labeling lines 
# in the latex version \nllabel, \lnl, and \label all kind of do different
# things, however, since we postpone generating a line number until the
# line is digested, and each of these macros only makes sense if the line
# is numbered, we can make them all do the same things
for my $name (qw(nllabel lnl algoLabel))
{
	my $macroName 		= sprintf('\%s{}',$name);
	my $constructorName = sprintf('\latexml%s',$name);
    my $constructorDef  = sprintf('\latexml%s{}',$name);
    
    DefMacro($macroName, 
    sub
    {
        # add the new label to the list of labels for this line
        my ($gullet, $arg) = @_;
        
        my @response = (T_CS($constructorName), T_BEGIN);
        
        while( my $token = $arg->readToken )
        {
        	# FIXME: there are probably other tokens that are allowed in
        	# label names other than numbers, letters, and underscores
        	
        	
			if($token->getString eq '_')
			{
				push(@response, T_CS('\_'));
			}
			else
			{
				push(@response, $token);
			}
        }
        
        push(@response, T_END);
        
        #return empty list of tokens
        return @response;
    });
    
    
    DefConstructor($constructorDef, 
    sub
    {
        # add the new label to the list of labels for this line
        my ($gullet, $arg) = @_;
        
        # if this is a label after the caption, then we put it on the algorithm
        # not the line
        if( $algorithmSettings->{'is-captioned'} )
        {
            # FIXME: should allow more than one label per algorithm
            $currentAlgorithmNode->setAttribute('labels',CleanLabel($arg));
        }
        
        else
        {
            my $labelArray     = $lineSettings->{'labels'};
            push( @$labelArray, CleanLabel($arg) );
            
            # ensure that this line will get a number
            $lineSettings->{'should-number'} = 1;
        }        
        
        
        #return empty list of tokens
        #()
    });
}


# indicates that the current line should be numbered. In LaTeX, this must come
# first in the line, but we don't actually care for latexml
DefConstructor('\nl', 
sub
{
    $lineSettings->{'should-number'} = 1;
    
    #return empty list of tokens
    #()
});

# set the text for the line "number" output, instead of outputting the actual
# line number, will also be the text output when we use \ref{} if the 
# line is labeled
DefConstructor('\nlset{}',
sub
{
    # set the custom text
    my ($gullet, $arg) = @_;
    $lineSettings->{'reftext'} = $arg->toString;
    
    # set the flag indicating that it is custom text
    $lineSettings->{'is-custom-text'}=1;
    
    #return empty list of tokens
    #()
});

# set the text for the line "number" output and a label for the line at the
# same time
DefConstructor('\nlset{}{}',
sub
{
    # set the custom text
    my ($gullet, $text, $label) = @_;
    my $labelArray     = $lineSettings->{'labels'};
    $lineSettings->{'reftext'} = $text->toString;
    push( @$labelArray, $label );
    
    # set the flag indicating that it is custom text
    $lineSettings->{'is-custom-text'}=1;
    
    #return empty list of tokens
    #()
});

# indicates that theline number (or text) should be displayed, even if 
# the linesnumbered hidden is activated
DefConstructor('\ShowLn',
sub
{
    $lineSettings->{'should-print-number'}=1;
    
    #return empty list of tokens
    #()
});

# indicates that theline number (or text) should be displayed, and adds a label
# at the same time
DefConstructor('\ShowLn{}',
sub
{
    # set the custom text
    my ($gullet, $label) = @_;
    my $labelArray = $lineSettings->{'labels'};
    push( @$labelArray, $label );
    
    $lineSettings->{'should-print-number'}=1;
    
    #return empty list of tokens
    ()
});




                            
# ------------------------------------------------------------------------------
#                            default style macros
# ------------------------------------------------------------------------------

# -------------------------------------------------
#                  Standard Styles
# -------------------------------------------------
DefMacro('\KwSty{}'      , '\textbf{#1}'      );
DefMacro('\FuncSty{}'    , '\texttt{#1}'      );
DefMacro('\ArgSty{}'     , '\emph{#1}'        );
DefMacro('\DataSty{}'    , '\textsf{#1}'      );
DefMacro('\CommentSty{}' , '\texttt{#1}'      );
DefMacro('\NlSty{}'      , '\textnormal{#1}' );
DefMacro('\ProcNameSty{}', '\textbf{#1}' );
DefMacro('\ProcArgSty{}' , '\texttt{#1}' );

# -------------------------------------------------
#              Caption and Title Style
# -------------------------------------------------
DefMacro('\AlCapSty{}'      , '\textbf{#1}'     );
DefMacro('\AlCapNameSty{}'  , '\textnormal{#1}' );
DefMacro('\AlCapFnt{}'      , '\relax{#1}'      );
DefMacro('\AlCapNameFnt{}'  , '\relax{#1}'      );
DefMacro('\AlTitleSty{}'    , '\textbf{#1}'     );
DefMacro('\AlTitleFnt{}'    , '\relax{#1}'      );



# macros to redefine styles, each of these macros takes a single argument which
# is the textual name of a macro which takes a single argument
for my $styleKey(qw(
        Kw Func Arg Data Comment ProcName ProcArg 
        AlCapSty AlCapNameSty AlCapFnt AlCapNameFnt 
        AlTitleSty AlTitleFnt
))
{
    my $setterMacro = sprintf('\Set%sSty{}', $styleKey);
    my $styleMacro  = sprintf('\%sSty{}',    $styleKey);
    
    DefMacro($setterMacro,
    sub
    {
        my ($gullet, $arg) = @_;
        DefMacro($styleMacro, sprintf('\%s{#1}', $arg));
        
        # return empty token list
        ();
    });    
}

# the NlStyle macro (number line style) takes three arguments. First is the
# Style macro, then a prefix, then a suffix so that the line printed is like
# \textbf{ prefix #1 suffix }
DefMacro('\SetNlSty{}{}{}',
sub
{
    my ($gullet, $font,$pre,$post) = @_;
    DefMacro('\NlSty{}', sprintf('\%s{ %s #1 %s}', $font,$pre,$post));
    
    # return empty token list
    ();
});




# ------------------------------------------------------------------------------
#                            Controlloing Layout
# ------------------------------------------------------------------------------

# sets the boxed style of all following algorithms
DefMacro('\RestyleAlgo{}',
sub{
    
    my ($gullet, $arg) = @_;
    $globalSettings->{'boxed-style'} = $arg;
    
    # return empty token list
    ();
});

# sets the lined style 
for my $style( qw( Vlined Noline Lined ) )
{
    my $setterMacro = sprintf('\SetAlgo%s', $style);
    my $value       = lc($style);
    DefMacro($setterMacro,
    sub
    {
        $globalSettings->{'lined-style'} = $value;    
        
        # return empty token list
        return ();
    });
}

# sets the end style
for my $style( qw(LongEnd ShortEnd NoEnd) )
{
    my $setterMacro = sprintf('\SetAlgo%s', $style);
    my $value       = lc($style);
    DefMacro($setterMacro,
    sub
    {
        $globalSettings->{'end-style'} = $value;    
        
        # return empty token list
        return ();
    });
}


# ------------------------------------------------------------------------------
#                       Utility macros
# ------------------------------------------------------------------------------

# informs the constructor that this is an input line, so don't number it unless
# the settings indicate to
DefConstructor('\algoSetInputLine',
sub
{
    my ($document,$arg) = @_;
    $lineSettings->{'is-input'} = 1;
    
    #return empty token list
    #();
});

# informs the constructor that this is an input line, so don't number it unless
# the settings indicate to
DefConstructor('\algoSetCommentLine',
sub
{
    $lineSettings->{'is-comment'} = 1;
    #return empty token list
    #();
});

# informs the constructor that this line should have a hidden style (the 
# stylesheet will give it 0px height), this is a placeholder for the end tick
# in the vlined style
DefConstructor('\algoHideLine',
sub
{   
    $lineSettings->{'is-hidden'} = 1;
    #return empty token list
    #();
});

DefConstructor('\algoConstructVline',
sub
{   
    my $document = shift;
    
    $document->openElement('ltx:inline-block');
    $document->setAttribute('class', 'algorithm2e-underbar');
    $document->closeElement('ltx:inline-block');
    #return empty token list
    #();
});



# handles the various styles of 'end' that we may encounter
DefMacro('\algoEndStatement{}',
sub
{
    my($gullet, $arg) = @_;
    
    my @result;
    
    # if we don't output any text for endings, then we tell the
    # constructor that this is a hidden line
    if($algorithmSettings->{'lined-style'} eq 'vlined'
       || $algorithmSettings->{'end-style'} eq 'noend' )
    {
        push(@result, T_CS('\algoHideLine'));   
    }
    
    # if the algorithm style is vlined, then we need to output the
    # little horizontal line in the rendered html
    if( $algorithmSettings->{'lined-style'} eq 'vlined' )
    {
        push(@result, T_CS('\algoConstructVLine'));
    }
    
    # if the line style is not vlined, then maybe we output an end marker
    else
    {
        # if the end style is long, then we keep the tokens that have been
        # digested
        if( $algorithmSettings->{'end-style'} eq 'longend' )
        {
            push(@result, $arg );
        }
        
        # if the end style is short, then we replace these tokens with the 
        # digestion of '\KwSty{end}'
        elsif( $algorithmSettings->{'end-style'} eq 'shortend' )
        {
            push(@result, Tokenize('\KwSty{end}'));
        }
            
        # otherwise we the end style his noend and we don't output anything
    }
    
    return @result;
});

# ------------------------------------------------------------------------------
#                       Setting new Keywords
# ------------------------------------------------------------------------------
our $CreateKwInputMacro = 
sub
{
    my ($gullet,$macro,$text) = @_;    
    my $command     = sprintf('\%s{}',$macro);
    my $expansion   = sprintf('\algoSetInputLine \KwSty{%s}: #1 \algoEndLine', $text);
    
    DefMacro($command,$expansion);
    
    # return empty token list
    ();
};


DefMacro('\SetKwInput{}{}',$CreateKwInputMacro);

our $CreateKwMacro =
sub
{
    my ($gullet, $macro,$text) = @_;    
    
    my $command     = sprintf('\%s',$macro);
    my $expansion   = sprintf('\KwSty{%s}', $text);
    
    DefMacro($command,$expansion);
    
    # return empty token list
    ();
};

DefMacro('\SetKw{}{}',$CreateKwMacro);


our $CreateCommentMacro =
sub
{
    my ($gullet, $macro,$open,$close) = @_;    
    
    my $command     = sprintf('\%s',$macro);
    my $expansion   = sprintf('\algoSetCommentLine \CommentSty{ %s #1 %s }', 
                                $open, $close);
    
    DefMacro($command,$expansion);
    
    # return empty token list
    ();
};


DefMacro('\SetKwComment{}{}{}',$CreateCommentMacro);


our $CreateIfMacros =
sub
{
    my($gullet,
        $ifMacro,$elseIfMacro,$elseMacro,
        $ifString,$thenString,$elseifString,
        $elseString,$endString) = @_; 
        
    # normal if statement with end statement and contents are a block
    DefMacro(
        sprintf('\%s{}{}', $ifMacro),
        sprintf('\KwSty{%s } \ArgSty{ #1 } \KwSty{ %s} '
                .'\algoBeginBlock #2 \algoEndBlock '
                .'\algoEndStatement{ \KwSty{%s} } \algoEndLine', 
                $ifString,
                $thenString,
                $endString
                )
            );
    
    # unfinished if statement, does not print an end so that an else can be
    # appended
    DefMacro(
        sprintf('\u%s{}{}', $ifMacro),
        sprintf('\KwSty{%s } \ArgSty{ #1 } \KwSty{ %s} '
                .'\algoBeginBlock #2 \algoEndBlock ',
                $ifString,
                $thenString
                )
            );
    
    # single line if statment, then block is on the same line
    DefMacro(
        sprintf('\l%s{}{}', $ifMacro),
        sprintf('\KwSty{%s } \ArgSty{ #1 } \KwSty{ %s} #2',
                $ifString,
                $thenString
                )
            );
    
    # same as if except uses 'elseif', used for continuation of uIf or lIf
    DefMacro(
        sprintf('\%s{}{}', $elseIfMacro),
        sprintf('\KwSty{%s } \ArgSty{ #1 } \KwSty{ %s} '
                .'\algoBeginBlock #2 \algoEndBlock '
                .'\algoEndStatement{ \KwSty{%s} } \algoEndLine', 
                $elseifString,
                $thenString,
                $endString
                )
            );
    
    # unfinished elseif
    DefMacro(
        sprintf('\u%s{}{}', $elseIfMacro),
        sprintf('\KwSty{%s } \ArgSty{ #1 } \KwSty{ %s} '
                .'\algoBeginBlock #2 \algoEndBlock ',
                $elseifString,
                $thenString
                )
            );
    
    # single line elseif
    DefMacro(
        sprintf('\l%s{}{}', $elseIfMacro),
        sprintf('\KwSty{%s } \ArgSty{ #1 } \KwSty{ %s} #2',
                $elseifString,
                $thenString
                )
            );
            
            
    # normal else statement with end statement and contents are a block
    DefMacro(
        sprintf('\%s{}', $elseMacro),
        sprintf('\KwSty{%s}  '
                .'\algoBeginBlock #1 \algoEndBlock '
                .'\algoEndStatement{ \KwSty{%s} } \algoEndLine', 
                $elseString,
                $endString
                )
            );
    
    # unfinished else statement, does not print an end so that an else can be
    # appended
    DefMacro(
        sprintf('\u%s{}', $elseMacro),
        sprintf('\KwSty{%s} '
                .'\algoBeginBlock #1 \algoEndBlock ',
                $elseString
                )
            );
    
    # single line else statment, then block is on the same line
    DefMacro(
        sprintf('\l%s{}', $elseMacro),
        sprintf('\KwSty{%s} #2',
                $elseString
                )
            );

    # combined if-else statement
    DefMacro('\eIf{}{}{}',  '\uIf{#1}{#2} \Else{#3}');
   
   #return empty token list     
   ();
};

DefMacro('\SetKwIF{}{}{}{}{}{}{}{}',$CreateIfMacros);


our $CreateSwitchMacros =
sub
{
     my($gullet,
        $switchMacro,     $caseMacro,   $otherMacro,
        $switchString,    $doString,    $caseString,
        $otherwiseString, $endString ) = @_;
        
    # switch statement
    DefMacro(
        sprintf('\%s{}{}', $switchMacro),  
        sprintf('\KwSty{%s } \ArgSty{ #1 } \KwSty{ %s} '
                .'\algoBeginBlock #2 \algoEndBlock '
                .'\algoEndStatement{ \KwSty{%s} } \algoEndLine',
                $switchString,
                $doString,
                $endString
               ) 
        );
    
    # case statement
    DefMacro(
        sprintf('\%s{}{}', $caseMacro),  
        sprintf('\KwSty{%s } \ArgSty{ #1 } '
                .'\algoBeginBlock #2 \algoEndBlock ',
                $caseString
               ) 
        );
        
    # unfinished case statement
    DefMacro(
        sprintf('\u%s{}{}', $caseMacro),  
        sprintf('\KwSty{%s } \ArgSty{ #1 }  '
                .'\algoBeginBlock #2 \algoEndBlock ',
                $caseString
               ) 
        );
        
    # singe line case statement
    DefMacro(
        sprintf('\l%s{}{}', $caseMacro),  
        sprintf('\KwSty{%s } \ArgSty{ #1 }  #2',
                $caseString
               ) 
        );
    
    # otherwise
    DefMacro(
        sprintf('\%s{}', $otherMacro),  
        sprintf('\KwSty{%s}   '
                .'\algoBeginBlock #1 \algoEndBlock ',
                $otherwiseString
               ) 
        );
    
    # singe line otherwise
    DefMacro(
        sprintf('\l%s{}', $otherMacro),  
        sprintf('\KwSty{%s} #1',
                $otherwiseString
               ) 
        );    
};

DefMacro('\SetKwSwitch{}{}{}{}{}{}{}{}',$CreateSwitchMacros);



our $CreateForMacros =
sub
{
     my($gullet,
        $forMacro, $forString, $doString,  $endString ) = @_;
        
    # usual forloop
    DefMacro(
        sprintf('\%s{}{}', $forMacro),  
        sprintf('\KwSty{%s } \ArgSty{ #1 } \KwSty{ %s} '
                .'\algoBeginBlock #2 \algoEndBlock '
                .'\algoEndStatement{ \KwSty{%s} } \algoEndLine',
                $forString,
                $doString,
                $endString
               ) 
        );
        
    # single line
    DefMacro(
        sprintf('\l%s{}{}', $forMacro),  
        sprintf('\KwSty{%s } \ArgSty{ #1 } \KwSty{ %s} #2 ',
                $forString,
                $doString
               ) 
        );
};

DefMacro('\SetKwFor{}{}{}{}',$CreateForMacros);


our $CreateRepeatMacros =
sub
{
     my($gullet,
        $repeatMacro, $repeatString, $untilString) = @_;
        
    # usual forloop
    DefMacro(
        sprintf('\%s{}{}', $repeatMacro),  
        sprintf('\KwSty{%s } '
                .'\algoBeginBlock #2 \algoEndBlock '
                .'\KwSty{%s } \ArgSty{ #1 } ',
                $repeatString,
                $untilString
               ) 
        );
        
    # single line
    DefMacro(
        sprintf('\l%s{}{}', $repeatMacro),  
        sprintf('\KwSty{%s } #2 \KwSty{ %s } \ArgSty{ #1 } ',
                $repeatString,
                $untilString
               ) 
        );
};

DefMacro('\SetKwRepeat{}{}{}',$CreateForMacros);


# ------------------------------------------------------------------------------
#                       Predefined Language Keywords
# ------------------------------------------------------------------------------
for my $pairs(  [qw(KwIn     Input)],
                [qw(KwData   Data)],
                [qw(KwOut    Output)],
                [qw(KwResult Result)]  )
{
    $CreateKwInputMacro->( 'gullet', $pairs->[0], $pairs->[1] );
}

for my $pairs(  [qw(KwTo    to)],
                [qw(KwRet   Return)],
                [qw(Return  Return)] )
{
    $CreateKwMacro->( 'gullet', $pairs->[0], $pairs->[1] );
}



DefMacro('\KwEnd',      '\KwSty{end}'       );

# if/else macros
$CreateIfMacros->( qw(gullet If ElseIf Else if then elseif else endif) );

# switch/case
$CreateSwitchMacros->( qw(gullet Switch Case Other switch do case otherwise endsw) );

# for, while, foreach
$CreateForMacros->( qw(gullet For      for      do  endfor) );
$CreateForMacros->( qw(gullet While    while    do  endw) );
$CreateForMacros->( qw(gullet ForEach  foreach  do  endfch) );
$CreateForMacros->( qw(gullet ForAll   forall   do  endfall) );

# repeat/until  do/while
$CreateRepeatMacros->( qw( gullet Repeat   repeat until ) );
$CreateRepeatMacros->( qw( gullet DoWhile  do     while ) );




DefMacro('\algoCaption{}',  
    '\beginAlgoCaption \AlCapSty{\AlCapFnt{ Algorithm \constructAlgoNum : }}  {#1} \endAlgoCaption');
    
DefConstructor('\constructAlgoNum',sub{
    my $document = shift;
    $document->absorb( Digest(Tokenize( $algorithmSettings->{'algo-number'} )));
});




# In user code (i.e a latex document) the user only ever gives us an indication
# of ending a line (\;). We will do layout at the line level so what we'll do
# is any time we come across one of these line endings we'll put a "line split"
# in other words we always assume that there is an open "line" xml block. Then,
# when we hit one of thise (\;) control codes, what we'll do is split that 
# currently open line, so that everything currently digested goes before the
# split, and there now "current" line is empty
#
# An alternate explanation. There is always a current "line". As we digest code
# we put it into that line. Then when we hit a (\;) control code, we split that
# current line after whatever has been digested so far. The left half of that 
# split is considered done, and the right half is where future digestion
# gets output.
DefConstructor('\algoEndLine',sub{
    my $document = shift;
    algoEndLine($document);
    algoBeginLine($document);
}); 

# When we start a new block we need to close the currenly opened line, then
# start a new block, and then start a new line within that block
DefConstructor('\algoBeginBlock',sub{
    my $document = shift;
    algoEndLine($document);
    algoBeginBlock($document);
    algoBeginLine($document);
});

# when we end a block, we need to close the active line, then close the active
# block, and then open a new line so that more stuff can be put into it
DefConstructor('\algoEndBlock',sub{
	my $document = shift;
	algoCancelLine($document);
	algoEndBlock($document);
	algoBeginLine($document);
});


# when the algorithm environment is started we need to insert some custom 
# code handlers before digestion proceeds
DefConstructor('\algorithm[]',
    sub 
    {
        # to start the algorithm block, we open the environment,
        # then the first block in that environment, then the first line in
        # that block
    	my $document = shift;
    	algoBeginEnv($document);
    	algoBeginBlock($document);
    	algoBeginLine($document);
    },
    # before digestion, we need to redefine some commands so that 
    beforeDigest=>
    sub{
    	my $stomach = shift;
    	
    	# store the current meaning of '\;' and '\caption' so that we can 
    	# restore them later
    	Let('\algoOldSemicolon',   '\;');
    	Let('\algoOldCaption',     '\caption');
    	Let('\algoOldLabel',       '\label');
    	
    	# now redefine them to our binding hooks so that we are notified when
    	# these controls are encountered
    	Let('\;'      ,   '\algoEndLine');
    	Let('\caption',   '\algoCaption');
    	Let('\label',     '\algoLabel');
    }    
);

# when the algorithm environment is ended we need to restore the old definitions
# for the \; and \caption controls
DefConstructor('\endalgorithm',
    sub
    {
        # since the algorithm is ended we close the current line and delete it
        # (because it should be empty) then close the open block and the open
        # environment
    	my $document = shift;
    	algoCancelLine($document);
    	algoEndBlock($document);
    	algoEndEnv($document);
    },
    beforeDigest=>
    sub
    {
        my $stomach = shift;
        Let('\;',       '\algoOldsemicolon');
        Let('\caption', '\algoOldCaption');
        Let('\label',   '\algoOldLabel');
    }
);

# if we encounter a caption for the algorithm, we make the caption element
# the active element of the document, so that the caption code gets digested
# into the correct part of the document tree
DefConstructor('\beginAlgoCaption',sub{
	my $document = shift;
	
	# we cache the current node (whatever it is) so that when the caption is
	# complete we can make it current again
	$restoreNode = $document->getNode;
	
	# now set the "current" or active node to be the caption element
	$document->setNode($currentCaptionNode);
});

# when the caption is digested, we restore whatever active node was set prior
# to the caption being started
DefConstructor('\endAlgoCaption',sub{
	my $document = shift;
	$document->setNode($restoreNode);
	
	$algorithmSettings->{'is-captioned'} = 1;
});

# the \algoSingleLineNumberOff control indicates that this line should not
# be numbered, so we simply set the flag
DefConstructor('\algoSingleLineNumberOff',sub{$singleLineNumberOff=1;});

# the \algoSingleLineNumberOn control indicates that this line should be
# numbered, so we simply set the flag
DefConstructor('\algoSingleLineNumberOn', sub{$singleLineNumberOn =1;});



# Begins outputting an algorithm to the xml document
# 
# an algorithm environment maps to a <ltx:float> in latxml schema 
# this in turn maps to an html <div>.
# signature: algoBeginEnv( $document ) 
sub algoBeginEnv
{
    # parameter is the xml document
    my $document = shift;
    
    # create a reference uid by incrementing the 'algorithm'
    # counter. This counter prefixes the counter number with 'A' so
    # algorithm 4 would have a ref name of "A4"
    my %ref      = RefStepCounter('algoAlgo');
    
    # open the ltx:float element
    $currentAlgorithmNode =
    $document->openElement("ltx:float");
    
    # add the attributes needed for cross referencing
    $document->addAttribute("refnum"=>$ref{'refnum'});
    $document->addAttribute("xml:id"=>$ref{'id'});
    
    # add the algorithm2e class name (this will become a css class name in the
    # class attribute of the html div element)
    $document->addAttribute("class"=>"algorithm2e");
    
    # now open a caption child element to the algorithm give it a 
    # class name of algorithm2e-caption so we can style it, and then
    # immediately close it. We grab a pointer to this node before we
    # close it
    #
    # The reason we do it this way is that the user may or may not 
    # include a caption. But if they do it will likely be at the end
    # of the environment. We need to be able to insert the caption
    # text wherever we find the caption. 
    $currentCaptionNode =
    $document->openElement("ltx:caption");
    $document->addAttribute("class"=>"algorithm2e-caption");
    $document->closeElement("ltx:caption");
    
    # initialize the depth to 0. This is the depth in terms of code
    # blocks (loops, conditionals) and dictates how far to increment
    # the code block
    $algoDepth   = 0;

    # set the settings of this algorithm to be those of the document defaults,
    # note that they may be changed when certain macros within the environment
    # are encountered
    $algorithmSettings= dclone($globalSettings);
    $algorithmSettings->{'algo-number'} = $ref{'refnum'};
}


# End outputting an algorithm to the xml document
#
# At the close of the algorithm environment we simply close the 
# opened ltx:float element
sub algoEndEnv
{
    # attach styles to the algorithm block
    $currentAlgorithmNode->setAttribute("class"=>sprintf(
        "algorithm2e algorithm2e-%s", $algorithmSettings->{'boxed-style'}
    )); 
    
	my $document = shift;
    $document->closeElement("ltx:float");
}

# Begin outputting a block of algorithm code
#
# A block of algorithm code is reprsented in the xml schema by an
# ltx:inline-block element. 
sub algoBeginBlock
{
	my $document = shift;
	
	# increment the block counter so that we can get unique 
	# reference entry for this block
	my %ref      = RefStepCounter('algoBlock');
	
	# increment the algorithm depth (i.e. how deep in the nested
	# block structure of the algorithm we are)
    $algoDepth = $algoDepth + 1;
    
    # now open the actual element
    $document->openElement("ltx:inline-block");
    
    # set the depth attribute of the inline-block element to be the
    # depth of the block (this is an abuse and should be changed, 
    # perhaps we can use a fixed number of block classes instead)
    if( $algoDepth > 1 )
    {
        $document->addAttribute(
            "class"=>sprintf("algorithm2e-block-x",$algoDepth) );
    }
    else
    {
        $document->addAttribute(
            "class"=>sprintf("algorithm2e-block-0",$algoDepth) );
    }
    
    # set the cross reference information based on the counter for
    # algorithm blocks
    $document->addAttribute("refnum"=>$ref{'refnum'});
    $document->addAttribute("xml:id"=>$ref{'id'});
}

# End output of a block of algorithm cocde
sub algoEndBlock
{
	my $document = shift;
	
	# first close the ltx:inline-block element
	$document->closeElement("ltx:inline-block");
	
	# then we decrement the depth
	$algoDepth = $algoDepth - 1;
}

# Starts a new algorithm line
#
# A line of pseudo code maps to a ltx:p element
sub algoBeginLine
{
    my $document = shift;

    # this is the container for the line, it is a div in html
    $document->openElement("ltx:inline-block");
    $document->addAttribute("class"=>"algorithm2e-line");
    
    # this is the placeholder for the label
    $document->openElement("ltx:inline-block");
    $document->addAttribute("class"=>"algorithm2e-lineno-pos");
    
    # this is the actual label element, a ltx:p
    $currentLineLabelNode =
    $document->openElement("ltx:p");
    $document->addAttribute("class"=>
            sprintf("algorithm2e-lineno algorithm2e-lineno-%d",$algoDepth-1) );
            
    # we can close these last two nodes
    $document->closeElement("ltx:p");
    $document->closeElement("ltx:inline-block");
    
    # and this is the actual contents of the line
    $currentLineNode = 
    $document->openElement("ltx:p");
    
    # assign a class name of algoirthm2e-line so that we can style it with
    # css
    $document->addAttribute("class"=>"algorithm2e-line-text");
    
    # initialize the line settings to the defaults
    $lineSettings =  dclone($defaultLineSettings);
}

# End output of an algorithm line
sub algoEndLine
{
	my $document = shift;
	my %ref;

    # if this is a hidden line then we dont need to do much introspection
    if($lineSettings->{'is-hidden'})
    {
        # create and write out the xml:id of this element
        %ref = RefStepID('algoLine');
        $currentLineNode->setAttribute("xml:id",ToString($ref{'id'}));  
        
        # then close the currently opened elements
        $document->closeElement("ltx:p");
        $document->closeElement("ltx:inline-block");
    }
    
    else
    {
	
    	# we may have to assign the line a number if
    	#     1. the latex code explicitly sets this line to use numbering
    	#     2. the policy for this algorithm is to do line numbering and the
    	#        latex code has not explicitly turned of line numbering for this
    	#        line
    	my $shouldNumber = 
    	( 
        	$lineSettings->{'should-number'}
    	       || (    $algorithmSettings->{'lines-numbered'} 
                        && ! $lineSettings->{'is-input'}
                        && ! $lineSettings->{'is-comment'} )
               || (    $algorithmSettings->{'input-numbered'}
                        &&   $lineSettings->{'is-input'} )
               || (    $algorithmSettings->{'comments-numbered'}
                        &&   $lineSettings->{'is-comment'} )
        );
    	
    	if( $shouldNumber )
        {
            %ref = RefStepCounter('algoLine');
            $currentLineNode->setAttribute("refnum",ToString($ref{'refnum'}));
        }
        else
        {
            %ref = RefStepID('algoLine');
        }
    
        $currentLineNode->setAttribute("xml:id",ToString($ref{'id'}));	
    	
        # assign any labels that the user has created for this line
        my $labelsRef = $lineSettings->{'labels'};
        my @labels;
        
        foreach my $label(@$labelsRef)
        {
            push(@labels, sprintf("%s", $label));
        }
        
        my $labelString = join(' ',@labels);
        if( length($labelString) > 0 )
        {
            $currentLineNode->setAttribute('labels', join(' ', @labels));
        }
        
        
        # then we close the opened ltx:p element and it's containing 
        # inline-block element
        $document->closeElement("ltx:p");
        $document->closeElement("ltx:inline-block");
        
        my $shouldLabel = 
        (
            $lineSettings->{'should-print-number'}
            || $algorithmSettings->{'lines-labeled'}
        ) && $shouldNumber;     
               
        if( $shouldLabel )
        {
            # now, in the event that the line label needs to be output, we fill 
            # it here, so start by grabbing a pointer to the current node
            my $returnMeToTheThrone = $document->getNode;
            
            # make the label node the active node
            $document->setNode($currentLineLabelNode);
            
            if($lineSettings->{'is-custom-text'})
            {
                # Send the line number through the digestive track
                $document->absorb(Digest(Tokenize( 
                    sprintf('\NlSty{ %d }',$lineSettings->{'reftext'}) )) );
            }
            else
            {
                # Send the line number through the digestive track
                $document->absorb(Digest(Tokenize( 
                    sprintf('\NlSty{ %d }',$ref{'refnum'}) )) );
            }
            
            
            # restore the old current node
            $document->setNode($returnMeToTheThrone);
        }
    
    }
    
}

# Since we always have one line open, we may need to remove the last line
# from the document after the algorithm is complete
sub algoCancelLine
{
    my $document = shift;
    $document->setNode($currentLineNode);
    $document->maybeCloseElement("ltx:p");
    $document->closeElement("ltx:inline-block");
}




1;
